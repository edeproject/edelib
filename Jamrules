#
# $Id$
#
# Part of edelib.
# Copyright (c) 2005-2007 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.

JAMCONFIG ?= $(TOP)/Jamconfig ;
include $(JAMCONFIG) ;

if ! $(JAMCONFIG_READ) {
	Exit "Can't find Jamconfig. Did you run 'configure' first ?" ;
}

if $(SHARED) = 1 {
	LIBTOOL += "$(LIBTOOL) --silent" ;

	SUFOBJ_SHARED = ".lo" ;
	SUFLIB_SHARED = ".la" ;
}

# only for haiku jam
JCACHEFILE = $(TOP)/.jamcache ;
HCACHEFILE = $(TOP)/.jamhcache ;

# these variables should be here (not in Jamconfig) since RMDIR
# is already defined as 'rm -f' in Jambase, and calling 'jam distclean'
# will revert it's value when we remove Jamconfig
RMDIR   = "rm -R" ;
COPYDIR = "cp -R" ;

# general flags we pull from Jamconfig, with addition of include
# directory search, so compiler can find edelib include directory
FLAGS  = $(ALLFLAGS) -I$(TOP) ;

# standard C++ library we link with; for now is gcc's default
STDLIB ?= stdc++ ;

# variables used by jam directly
# OPTIM is cleared so it don't collide with FLAGS
OPTIM    = ;
CCFLAGS  = $(FLAGS) ;
C++FLAGS = $(FLAGS) ;

# directories used to place final library and 
# by tests to construct correct paths
EDELIB_INCLUDEDIR = edelib ;
EDELIB_LIBDIR     = lib ;

# library names
EDELIB           = edelib ;
EDELIB_NAME      = libedelib ;
EDELIB_DBUS      = edelib_dbus ;
EDELIB_DBUS_NAME = libedelib_dbus ;

# directory name for installed documentation
EDELIB_DOCDIR      = "$(EDELIB)-$(EDELIB_VERSION)" ;

# Haiku jam have builtin LocalClean and LocalDepends
if ! $(INVOCATION_SUBDIR_SET) {
	rule LocalClean { Clean $(1) : $(2) ; }
	rule LocalDepends { Depends $(1) : $(2) ; }
}

# same as FDirName, but targeted to files
rule FFileName
{
	return [ FDirName $(<) ] ;
}

# Cleandir cleandir : <directory> ;
# Removes directory in 'Clean clean' fashion
actions piecemeal together existing Cleandir
{
	$(RMDIR) $(>)
}

# Clean for libtool
actions piecemeal together existing LibtoolClean
{
	$(LIBTOOL) --mode=clean $(RM) $(>)
}

# LinkAgainst <target> : <libraries> ;
# The sam as jam's LinkLibraries, but will not mark those libraries 
# for building. <libraries> should be in form '-lfoo'
rule LinkAgainst
{
	LINKLIBS on $(1) = [ on $(1) return $(LINKLIBS) ] $(2) ;
}

# MakeLibrary <library> : <source> ;
# Create <library> and place it in $(EDELIB_LIBDIR). Library name should
# be in from 'libexample', without extension
rule MakeLibrary
{
	local path = [ FFileName $(TOP) $(EDELIB_LIBDIR) $(1) ] ;

	if $(SHARED) = 1 {
		SharedLibrary $(path) : $(2) ;
	} else {
		Library $(path) : $(2) ;
	}

	if $(3) != "noinstall" {
		if $(SHARED) = 1 {
			InstallSharedLibrary $(libdir) : $(path) ;
		} else {
			InstallStaticLibrary $(libdir) : $(path) ;
		}
	}
}

rule LibraryObjectCcFlags 
{
	if $(SHARED) = 1 {
		CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ_SHARED)) ] += $(>) ;
	} else {
		ObjectCcFlags $(<) : $(>) ;
	}
}

rule LibraryObjectC++Flags 
{
	if $(SHARED) = 1 {
		C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ_SHARED)) ] += $(>) ;
	} else {
		ObjectC++Flags $(<) : $(>) ;
	}
}

# SharedLibrary <library> : <source> ;
# Creates shared library with libtool
rule SharedLibrary
{
	if ! $(UNIX)  {
		Exit "Don't know how to build shared libraries on this platform" ;
	}

	if ! $(LIBTOOL) {
		Echo "Unable to find libtool!" ;
		Exit "If you already have it, please set LIBTOOL environment variable so it points to libtool executable" ;
	}

	SharedLibraryFromObjects $(<) : $(>:S=$(SUFOBJ_SHARED)) ;
	SharedObjects $(>) ;
}

rule SharedLibraryFromObjects
{
	local _i _l _s ;

	# Add grist to file names
	_s = [ FGristFiles $(>) ] ;
	_l = $(<:S=$(SUFLIB_SHARED)) ;

    # library depends on its member objects
	if $(KEEPOBJS) {
		LocalDepends obj : $(_s) ;
	} else {
		LocalDepends lib : $(_l) ;
	}

	# Set LOCATE for the library and its contents.  The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.

	if ! $(_l:D) {
		MakeLocate $(_l) : $(LOCATE_TARGET) ;
	}

	# we never scan shared libraries for member objects
	LocalDepends $(_l) : $(_s) ;

	# clean library via libtool
	LibtoolClean clean : $(_l) ;

	# Split X.X.X to X:X:X so we can feed libtool with it.
	# I'm not sure is it intented, but seems there is a bug inside
	# jam regex: matched grouped items will start from 1 and item at 1 position
	# will also be at 0 position
	local v = [ MATCH "^([0-9])\.([0-9])\.([0-9])$" : $(EDELIB_VERSION) ] ;
	local version_part = "" ;

	# If we matched numbers, just add this flag to the libtool
	if $(v) {
		version_part = "-version-info $(v[1]):$(v[2]):$(v[3])" ;
	}

	LINK on $(_l) = "$(LIBTOOL) --tag=CXX --mode=link $(LINK) -rpath $(libdir) $(version_part)" ;
	Link $(_l) : $(_s) ;
}

rule SharedObjects
{
	# temporary replace SUFOBJ since Objects rule use it
	local SUFOBJ = $(SUFOBJ_SHARED) ;

	CC on [ FGristFiles $(<:S=$(SUFOBJ_SHARED)) ] = "$(LIBTOOL) --tag=CC --mode=compile $(CC) -prefer-pic" ;
	C++ on [ FGristFiles $(<:S=$(SUFOBJ_SHARED)) ] = "$(LIBTOOL) --tag=CXX --mode=compile $(C++) -prefer-pic" ;

	# call the normal Objects rule
	Objects $(<) ;
}

# MakeTest <bin> : <source> : <optional-addon-libs> : <option>
rule MakeTest
{
	local lpath ;

	if $(SHARED) = 1 {
		lpath = [ FDirName $(TOP)/$(EDELIB_LIBDIR)/.libs ] ;
	} else {
		lpath = [ FDirName $(TOP)/$(EDELIB_LIBDIR) ] ;
	}

	Main $(1) : $(2) ;
	LinkAgainst $(1) : -L$(lpath) -l$(EDELIB) ;

	if $(3) {
		LinkAgainst $(1) : $(3) ;
	}

	if $(4) = "use-dbus" {
		LinkAgainst $(1) : -l$(EDELIB_DBUS) ;
	}

	LinkAgainst $(1) : -l$(STDLIB) ;
}

# MakeInstallPrivate <location-dir> : <targets> : <opt-file-mode> : <opt-chown> : <opt-chgrp> ;
rule MakeInstallPrivate
{
	local i t s ;
	local dir = $(1) ;

	MkDir $(dir) ;

	# This was pain-in-the-ass to set up (bad docs)
	# but this is the shortest possible explaination of it:
	# files must be gristed (or foo/foo will not be build) and _after_
	# that apply SEARCH on it, consulting SUBDIR. Otherwise
	# known targets will be compiled, but unknown (icons etc.) will not
	# be recognized as installable entity.
	s = [ FGristFiles $(2) ] ;
	SEARCH on $(s) = $(SUBDIR) ;

	for i in $(s) {
		t = $(i:BSR=$(dir):G=installed) ;
		LocalDepends $(t) : $(i) ;
		LocalDepends $(t) : $(dir) ;

		LocalDepends install : $(t) ;
		LocalClean uninstall : $(t) ;

		Install1 $(t) : $(i) ;

		if $(3) {
			MODE on $(t) = $(3) ;
			Chmod $(t) ;
		}

		if $(4) {
			OWNER on $(t) = $(4) ;
			Chown $(t) ;
		}

		if $(5) {
			GROUP on $(t) = $(5) ;
			Chgrp $(t) ;
		}
	}
}

# InstallStaticLibrary <location-dir> : <library> ;
rule InstallStaticLibrary
{
	MakeInstallPrivate $(<) : $(>:S=$(SUFLIB)) : $(FILEMODE) ;
}

# InstallSharedLibrary <location-dir> : <library> ;
rule InstallSharedLibrary
{	
	local i t s ;
	local dir = $(1) ;

	MkDir $(dir) ;

	s = [ FGristFiles $(2:S=$(SUFLIB_SHARED)) ] ;
	SEARCH on $(s) = $(SUBDIR) ;

	for i in $(s) {
		t = $(i:BSR=$(dir):G=installed) ;
		LocalDepends $(t) : $(i) ;
		LocalDepends $(t) : $(dir) ;

		LocalDepends install : $(t) ;
		UninstallSharedLibrary1 uninstall : $(t) ;

		InstallSharedLibrary1 $(t) : $(i) ;
	}
}

actions InstallSharedLibrary1
{
	$(LIBTOOL) --mode=install $(CP) "$(>)" "$(<)" ;
}

actions piecemeal together existing UninstallSharedLibrary1
{
	$(LIBTOOL) --mode=uninstall $(RM) "$(>)" ;
}

# InstallProgram <location-dir> : <program> ;
# EXEMODE is not used (jam set it to 711)
rule InstallProgram
{
	MakeInstallPrivate $(<) : $(>) ;
}

# InstallDocumentation <location-dir> : <file> ;
rule InstallDocumentation
{
	MakeInstallPrivate $(<) : $(>) : $(FILEMODE) ;
}

# InstallFile <location-dir> : <file> ;
rule InstallFile
{
	MakeInstallPrivate $(<) : $(>) : $(FILEMODE) ;
}

# InstallDirectory <location-dir> : <directory> ;
rule InstallDirectory
{
	local dir = $(1) ;

	MkDir $(dir) ;

	s = [ FGristFiles $(2) ] ;
	SEARCH on $(s) = $(SUBDIR) ;

	for i in $(s) {
		t = $(i:BSR=$(dir):G=installed) ;
		LocalDepends $(t) : $(i) ;
		LocalDepends $(t) : $(dir) ;

		LocalDepends install : $(t) ;
		Cleandir uninstall : $(t) ;

		CP on $(t) = $(COPYDIR) ;
		Install1 $(t) : $(i) ;
	}
}

actions Install1
{
	$(CP) "$(>)" "$(<)"
}

NotFile install ;

# a generated junk
LocalClean distclean : 
	$(TOP)/configure 
	$(TOP)/aclocal.m4 
	$(TOP)/Jamconfig 
	$(TOP)/edelib-config
	$(TOP)/edelib.pc
	$(TOP)/edelib-dbus.pc
	$(TOP)/config.log 
	$(TOP)/config.status 
	$(TOP)/edelib/_conf.h.in 
	$(TOP)/edelib/_conf.h 
	$(TOP)/edelib/Version.h 
	$(JCACHEFILE)
	$(HCACHEFILE) ;

Cleandir distclean : $(TOP)/autom4te.cache ;

#
# $Id$
#
# Part of edelib.
# Copyright (c) 2005-2007 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.

# tools
DOXYGEN ?= doxygen ;
DIRNAME ?= dirname ;
LINKCMD ?= ln -s ;
SED		?= sed ;
AWK		?= awk ;

RMDIR   = rm -R ;
COPYDIR = cp -R ;

# install script
INSTALL      ?= [ FDirName $(TOP) install-sh ] ;
INSTALL_LIB  ?= "$(INSTALL) -c" ;
INSTALL_DATA ?= "$(INSTALL) -m 644" ;
INSTALL_DIR ?= $(COPYDIR) ;

# where to install data
# Note: do not use '?=' since it have lower precendence
# here and will read data from environmend
# (or we should change variables ?)
#PREFIX    ?= "/opt/ede" ;
PREFIX     = ;
INCLUDEDIR = $(PREFIX)/include ;
LIBDIR     = $(PREFIX)/lib ;
DOCDIR     = $(PREFIX)/doc/ede ;

# flags
FLAGS  ?= -Wall -g3 -D_DEBUG -I$(TOP) ;
STDLIB ?= stdc++ ;
SHARED ?= ;
# clear flag, so we can set it elsewhere
OPTIM = ;

# directories
EDELIB_INCLUDEDIR = edelib ;
EDELIB_LIBDIR = lib ;

# library names
EDELIB = edelib ;
EDELIB_NAME = libedelib ;

# extensions
SOEXT = .so ;
SOEXTFULL = $(SOEXT).2.0.0 ;
SOFLAGS = -fPIC ;

JUNK = "> /dev/null" ;

if $(SHARED)
{
	FLAGS += $(SOFLAGS) ;
	SUFLIB = $(SOEXTFULL) ;
}

# this is used by jam
CCFLAGS = $(FLAGS) $(LOCALFLAGS) ;
C++FLAGS = $(FLAGS) $(LOCALFLAGS) ;

# at least we differ for FDirName
rule FFileName
{
	return [ FDirName $(<) ] ;
}

# creates symlink
# SymLink <link> : <source> : <path-for-source> ;
rule SymLink
{
	if $(LINKCMD)
	{
		# $(>) contains real path, not cheated one :-)
		DEPENDS $(<) : $(>) ;
		DEPENDS all : $(<) ;
		# cheat, so we don't confuse LINKCMD
		SymLink1 $(<) : $(>:D=$(3)) ;
		Clean clean : $(<) ;
	}
}

actions SymLink1
{
	$(LINKCMD) $(>) $(<) ;
}

# a hacked version of LibraryFromObjects
# so we can make shared library
rule SharedLibraryFromObjects
{
	local _i _l _s ;

	# Add grist to file names
	_s = [ FGristFiles $(>) ] ;
	_l = $(<:S=$(SUFLIB)) ;

	# library depends on its member objects
	if $(KEEPOBJS)
	{
		DEPENDS obj : $(_s) ;
	}
	else
	{
		DEPENDS lib : $(_l) ;
	}

	# Set LOCATE for the library and its contents.	The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.
	if ! $(_l:D)
	{
		MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
	}

	if $(NOARSCAN) 
	{ 
		# If we can't scan the library to timestamp its contents,
		# we have to just make the library depend directly on the
		# on-disk object files.  

		DEPENDS $(_l) : $(_s) ;
	}
	else
	{
		# If we can scan the library, we make the library depend
		# on its members and each member depend on the on-disk
		# object file.

		DEPENDS $(_l) : $(_l)($(_s:BS)) ;

		for _i in $(_s)
		{
			DEPENDS $(_l)($(_i:BS)) : $(_i) ;
		}
	}

	Link $(_l) : $(_s) ;
	Clean clean : $(_l) ;

	# If we can't scan the library, we have to leave the .o's around.
	if ! ( $(NOARSCAN) || $(KEEPOBJS) ) { RmTemps $(_l) : $(_s) ; }
}


# create either static of dynamic library
rule MakeLibrary
{
	if $(SHARED)
	{
		if ! $(UNIX)
		{
			Exit "Dynamic libraries can't be built on this OS for now" ;
		}

		local target tlink ;
		target = $(<)$(SOEXTFULL) ;
		tlink  = $(<)$(SOEXT) ;

		# we must have exact name or linking will fail
		LINKFLAGS on $(target) = -shared -Wl,-soname,$(<:D=)$(SOEXTFULL) -l$(STDLIB) ;

		SUFLIB on $(<) = $(SOEXTFULL) ;

		SharedLibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) ;
		Objects $(>) ;

		SymLink $(tlink) : $(target) : "" ;
		DEPENDS lib : $(tlink) ;
	}
	else
	{
		# call builtin one
		Library $(<) : $(>) ;
		InstallLibrary $(LIBDIR) : $(<)$(SUFLIB) ;
	}
}

rule MakeTest
{
	local elib = [ FFileName $(TOP) $(EDELIB_LIBDIR) $(EDELIB_NAME)$(SUFLIB) ] ;
	local ldir = [ FDirName $(TOP) $(EDELIB_LIBDIR) ] ;
	DEPENDS $(<)  : $(elib) ;
	DEPENDS tests : $(<) ;

	LINKLIBS on $(<) = -L$(ldir) -l$(EDELIB) -l$(STDLIB) ;
	Main $(<) : $(>) ;
}

rule MakeDocumentation
{
	if $(DOXYGEN) && $(DIRNAME)
	{
		DEPENDS doc : $(<) ;
		DEPENDS $(<) : $(>) ;
		DEPENDS all : doc ;

		MakeDocumentation1 $(<) : $(>) ;
		INSTALL on $(target) = $(INSTALL_DIR) ;
		InstallDocumentation $(DOCDIR) : $(<) ;
		Cleandir clean : $(<) ;
	}

	# just return if doxygen is not found
	# so we can build the rest
	if ! $(DOXYGEN)
	{
		Echo "doxygen is missing" ;
		Echo "To make documentation, you will need to install it" ;
		return ;
	}

	# dirname is used to compute path
	# since doxygen command must be run where Doxyfile exists
	if ! $(DIRNAME)
	{
		Echo "dirname is missing" ;
		Echo "To make documentation, go to $(<:P) and run doxygen" ;
		return ;
	}
}

# not used as MakeDocumentation because
# we want to run it only if DOXYGEN is defined
actions piecemeal MakeDocumentation1
{
	dn=`$(DIRNAME) $(>)`
	cd $dn
	$(DOXYGEN) $(>:B) $(JUNK) ;
}

# similar to GenFile, except it run
# a command on source
# GenDocumentation <target> : <command> <source>
rule GenDocumentation
{
	local target = $(<) ;
	local cmd = $(>[1]) ;
	local src = $(>[2]) ;

	DEPENDS $(target) : $(src) ;
	DEPENDS $(src) : $(cmd) ;
	DEPENDS doc : $(target) ;
	Clean clean : $(target) ;

	INSTALL on $(target) = $(INSTALL_DATA) ;
	InstallDocumentation $(DOCDIR) : $(target) ;
	Cleandir uninstall : $(DOCDIR) ;
}

actions GenDocumentation
{
	./$(>[1]) $(>[2]) > $(<) ;
}

# InstallLibrary <directory> : <library> ;
rule InstallLibrary
{
	local target ;

	target = [ FFileName $(<) $(>:D=) ] ;
	target = $(target:G=installibrary) ;

	Depends install : $(target) ;
	Depends install : all ;

	NotFile install ;
	Always install ;

	Install1 $(target) : $(>) ;
	INSTALL on $(target) = $(INSTALL_LIB) ;

	Clean uninstall : $(target) ;
}

# InstallLibrary <directory> : <docdir> ;
rule InstallDocumentation
{
	local target ;

	target = [ FFileName $(<) $(>:D=) ] ;
	target = $(target:G=installidocs) ;

	Depends install : $(target) ;
	Depends install : all ;

	NotFile install ;
	Always install ;

	Install1 $(target) : $(>) ;
}

actions Install1
{
	$(INSTALL) $(>) $(<) ;
}

actions piecemeal Package
{
	nm=`cat $(TOP)/edelib/Version.h | $(SED) -ne '/EDELIB_VERSION/p' | $(AWK) '{print $3}' | $(SED) -e 's/"//g'`
	tar -czpvf edelib-$nm.tar.gz $(TOP)/../edelib
}
Package archive ;

# allow to be used as Cleandir cleandir
actions piecemeal together existing Cleandir
{
	$(RMDIR) $(>)
}

actions quietly Help
{
	echo ""
	echo "Build options:"
	echo "   jam          build all"
	echo "   jam lib      make library only"
	echo "   jam doc      create documentation"
	echo "   jam tests    make tests"
	echo "   jam clean    clean compiled data"
	echo "   jam help     you already see it"
	echo ""
	echo "Options can be grouped too so to make library"
	echo "and tests, command is: 'jam lib tests'"
	echo ""
}
Help help ;


NOTFILE doc help archive tests ;
ALWAYS	doc help archive tests ;

#Cleandir distclean : autom4te.cache ;
#Clean distclean : config.h config.log config.status configure ;

#
# $Id$
#
# Part of edelib.
# Copyright (c) 2005-2007 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.


#JAMCONFIG ?= $(TOP)/Jamconfig ;
#include $(JAMCONFIG) ;
#if ! $(JAMCONFIG_READ)
#{
#	Exit "Can't find Jamconfig. Did you run 'configure' first ?" ;
#}

# these variables should be here (not in Jamconfig) since RMDIR
# is already defined as 'rm -f' in Jambase, and calling 'jam distclean'
# will revert it's value when we remove Jamconfig
RMDIR   = rm -R ;
COPYDIR = cp -R ;

# variables used by MakeSharedLibrary
#SOEXT     = $(DSOSYMLINK) ;
#SOEXTFULL = $(DSOSUFFIX) ;
#SOLDFLAGS = $(DSOLDFLAGS) ;
#SOFLAGS   = $(DSOFLAGS) ;

LINKCMD = $(SYMLINKCMD) ;

# testing
LINKCMD = "ln -s" ;
SHARED = "1" ;
SOEXTFULL = ".so.2.0.0" ;
SOEXT = ".so" ;
ALLFLAGS = "-Wall -shared" ;
DOXYGEN = "doxygen" ;

# general flags we pull from Jamconfig, with addition of include
# directory search, so compiler can find edelib include directory
FLAGS  = $(ALLFLAGS) -I$(TOP) ;

# standard C++ library we link with; for now is gcc's default
STDLIB ?= stdc++ ;

# variables used by jam directly
# OPTIM is cleared so it don't collide with FLAGS
OPTIM    = ;
CCFLAGS  = $(FLAGS) $(LOCALFLAGS) ;
C++FLAGS = $(FLAGS) $(LOCALFLAGS) ;

# directories used to place final library and 
# by tests to construct correct paths
EDELIB_INCLUDEDIR = edelib ;
EDELIB_LIBDIR     = lib ;

# library names
EDELIB      = edelib ;
EDELIB_NAME = libedelib ;

# construct path from list members
# same as FDirName, but targeted to files
rule FFileName
{
	return [ FDirName $(<) ] ;
}

# Cleandir cleandir : <directory> ;
# Removes directory in 'Clean clean' fassion
actions piecemeal together existing Cleandir
{
	$(RMDIR) $(>)
}

# SymLink <link> : <source> : <optional-path-to-source> ;
# create symbolic link from parameters, removing existing one
# it use LINKCMD variable and is expecting 'ln -s' style
rule SymLink
{
	if ! $(LINKCMD)
	{
		Exit "Don't know how to make symbolic link!" ;
	}

	Depends $(<) : $(>) ;
	Depends all : $(<) ;
	
	# replace directory part at source, so LINKCMD can operate
	# correctly; also mark it as NotFile since it does not exist
	# (at least for jam since path is stripped) and jam will not yell about it
	SymLink1 $(<) : $(>:D=$(3)) ;
	NotFile $(>:D=$(3)) ;

	Clean clean : $(<) ;
}

actions SymLink1
{
	$(RM) "$(<)" && $(LINKCMD) "$(>)" "$(<)"
}

# a hacked version of LibraryFromObjects
# so we can make shared library
rule SharedLibraryFromObjects
{
	local _i _l _s ;

	# Add grist to file names
	_s = [ FGristFiles $(>) ] ;
	_l = $(<:S=$(SUFLIB)) ;

	# library depends on its member objects
	if $(KEEPOBJS) 
	{
		DEPENDS obj : $(_s) ;
	}
	else 
	{
		DEPENDS lib : $(_l) ;
	}

	# Set LOCATE for the library and its contents.	The bound
	# value shows up as $(NEEDLIBS) on the Link actions.
	# For compatibility, we only do this if the library doesn't
	# already have a path.
	if ! $(_l:D) 
	{
		MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
	}

	if $(NOARSCAN) 
	{ 
		# If we can't scan the library to timestamp its contents,
		# we have to just make the library depend directly on the
		# on-disk object files.  

		DEPENDS $(_l) : $(_s) ;
	}
	else
	{
		# If we can scan the library, we make the library depend
		# on its members and each member depend on the on-disk
		# object file.

		DEPENDS $(_l) : $(_l)($(_s:BS)) ;

		for _i in $(_s)
		{
			DEPENDS $(_l)($(_i:BS)) : $(_i) ;
		}
	}

	Link $(_l) : $(_s) ;
	Clean clean : $(_l) ;

	# If we can't scan the library, we have to leave the .o's around.
	if ! ( $(NOARSCAN) || $(KEEPOBJS) ) { RmTemps $(_l) : $(_s) ; }
}

# MakeStaticLibrary <libname> : <sources> ;
# a rule using jam's default Library with meaningfull name
rule MakeStaticLibrary
{
	Library $(<) : $(>) ;
}

# MakeStaticLibrary <libname> : <sources> ;
# Create shared library, creating symlink to it.
#
# This is probably a good candidate for libtool backend, but
# later is story for it's own; for now we stick with direct compiler flags
# and if breaks something, addons will be done.
# It use SOEXTFULL as full shared library extension and SOEXT as symlink 
# extension to it.
rule MakeSharedLibrary
{
	if ! $(UNIX)
	{
		Exit "Dynamic libraries can't be built on this OS for now" ;
	}

	# make sure we have defined this one
	if ! $(SOEXTFULL) && ! $(SOEXT)
	{
		Exit "Library extension not defined" ;
	}
	
	Echo "...making shared library is experimental..." ;

	local target symlink target_only ;
	target = $(<:S=$(SOEXTFULL)) ;
	symlink  = $(<:S=$(SOEXT)) ;

	# target name without directory part so compiler can recognize
	# it as final library name and do linking without problems
	target_only = $(target:D=) ;

	# main linking part; for specific compilers, things should be tuned here
	LINKFLAGS on $(target) = -shared -Wl,-soname,$(target_only) -l$(STDLIB) ;

	# overwrite SUFLIB; do not use SUFLIB on target = XYZ since
	# 'on target' variables work only in actions, and SUFLIB is not
	# used in MakeSharedLibrary action (I had to write here since docs sucks!)
	SUFLIB = $(SOEXTFULL) ;

	SharedLibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) ;
	Objects $(>) ;

	SymLink $(symlink) : $(target) : "" ;
	Depends lib : $(symlink) ;
}

# MakeTest <target> : <sources> ;
# Rule used to correctly compule library path, do linking and stuff
# for edelib specific tests
rule MakeTest
{
	local elib = [ FFileName $(TOP) $(EDELIB_LIBDIR) $(EDELIB_NAME)$(SUFLIB) ] ;
	local ldir = [ FDirName $(TOP) $(EDELIB_LIBDIR) ] ;
	Depends $(<)  : $(elib) ;
	Depends tests : $(<) ;

	LINKLIBS on $(<) = -L$(ldir) -l$(EDELIB) -l$(STDLIB) ;
	Main $(<) : $(>) ;
}

# MakeApiDocumentation <full-path-to-directory> : <full-path-to-doxyfile> ;
# Create api documentation via doxygen; not full paths are required
# since doxygen don't have any external option to specify path for Doxyfile
# or path for output directory
rule MakeApiDocumentation
{
	if $(DOXYGEN)
	{
		Depends doc : $(<) ;
		Depends $(<) : $(>) ;
		Depends all : doc ;

		MakeApiDocumentation1 $(<) : $(>) ;
		Cleandir clean : $(<) ;
	}

	# just return if doxygen is not found
	# so we can build the rest
	if ! $(DOXYGEN)
	{
		Echo "doxygen is missing" ;
		Echo "To make documentation, you will need to install it" ;
		return ;
	}
}

# Strip directory path from (example: 'doc/Doxyfile') and
# go into it so DOXYGEN command can work
actions piecemeal MakeApiDocumentation1
{
	cd $(>:D)
	$(DOXYGEN) $(>:B) ;
}

# GenDocumentation <path-to-target> : <path-to-command> <path-to-source> ;
# Aimed for generating text files from doxygen source;
# probably this should be called GenerateFile or something.
rule GenDocumentation
{
	local target = $(<) ;
	local cmd = $(>[1]) ;
	local src = $(>[2]) ;

	Depends $(target) : $(src) ;
	Depends $(src) : $(cmd) ;
	Depends doc : $(target) ;
	Clean clean : $(target) ;
}

actions GenDocumentation
{
	./$(>[1]) $(>[2]) > $(<) ;
}

actions quietly Help
{
	echo ""
	echo "Build options:"
	echo "   jam          build all"
	echo "   jam lib      make library only"
	echo "   jam doc      create documentation"
	echo "   jam tests    make tests"
	echo "   jam clean    clean compiled data"
	echo "   jam help     you already see it"
	echo ""
	echo "Options can be grouped too so to make library"
	echo "and tests, command is: 'jam lib tests'"
	echo ""
}
Help help ;

NotFile help ;
Always help ;

#
# $Id$
#
# Part of edelib.
# Copyright (c) 2005-2007 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.

# only for haiku jam
JCACHEFILE = $(TOP)/.jamcache ;
HCACHEFILE = $(TOP)/.jamhcache ;

if $(NOJAMCFG) {
	# for testing purposes
	LINKCMD = "ln -s" ;
	SHARED = "" ;
	SOEXTFULL = ".so.2.0.0" ;
	SOEXT = ".so" ;
	ALLFLAGS = "-Wall -shared" ;
	DOXYGEN = "doxygen" ;
	libdir = "/opt/ede/lib" ;
	docdir = "/opt/ede/doc" ;
	includedir  = "/opt/ede/include" ;
	INSTALL         ?= "ginstall -c" ;
	INSTALL_DATA    ?= "$(INSTALL) -m 644" ;
	INSTALL_PROGRAM ?= "$(INSTALL)" ;
	INSTALL_SCRIPT  ?= "$(INSTALL)" ;
	EDELIB_VERSION  ?= "2.0.0a" ;
} else {
	JAMCONFIG ?= $(TOP)/Jamconfig ;
	include $(JAMCONFIG) ;

	if ! $(JAMCONFIG_READ) {
		Exit "Can't find Jamconfig. Did you run 'configure' first ?" ;
	}

	# variables used by MakeSharedLibrary
	SOEXT     = $(DSOSYMLINK) ;
	SOEXTFULL = $(DSOSUFFIX) ;
	SOLDFLAGS = $(DSOLDFLAGS) ;
	SOFLAGS   = $(DSOFLAGS) ;

	LINKCMD = $(SYMLINKCMD) ;
}

# these variables should be here (not in Jamconfig) since RMDIR
# is already defined as 'rm -f' in Jambase, and calling 'jam distclean'
# will revert it's value when we remove Jamconfig
RMDIR   = "rm -R" ;
COPYDIR = "cp -R" ;

# general flags we pull from Jamconfig, with addition of include
# directory search, so compiler can find edelib include directory
FLAGS  = $(ALLFLAGS) -I$(TOP) ;

# standard C++ library we link with; for now is gcc's default
STDLIB ?= stdc++ ;

# variables used by jam directly
# OPTIM is cleared so it don't collide with FLAGS
OPTIM    = ;
CCFLAGS  = $(FLAGS) ;
C++FLAGS = $(FLAGS) ;

# directories used to place final library and 
# by tests to construct correct paths
EDELIB_INCLUDEDIR = edelib ;
EDELIB_LIBDIR     = lib ;

# library names
EDELIB      = edelib ;
EDELIB_NAME = libedelib ;

# directory name for installed documentation
EDELIB_DOCDIR      = "$(EDELIB)-$(EDELIB_VERSION)" ;

# used by SymLink
SYMLINKSRCPATH = ;

rule GetOS
{
	local var ;
	var = [ MATCH "(.*[^ \t])" : $(JAMUNAME) ] ;
	return "$(var[5]) $(var[0])" ;
}

# construct path from list members
# same as FDirName, but targeted to files
rule FFileName
{
	return [ FDirName $(<) ] ;
}

# Cleandir cleandir : <directory> ;
# Removes directory in 'Clean clean' fashion
actions piecemeal together existing Cleandir
{
	$(RMDIR) $(>)
}

# LinkAgainst <target> : <libraries> ;
# The sam as jam's LinkLibraries, but will not mark those libraries 
# for building. <libraries> should be in form '-lfoo'
rule LinkAgainst
{
	LINKLIBS on $(1) = [ on $(1) return $(LINKLIBS) ] $(2) ;
}

# SymLink <link> : <source> : <optional-path-to-source> ;
# create symbolic link from parameters, removing existing one
# it use LINKCMD variable and is expecting 'ln -s' style
rule SymLink
{
	if ! $(LINKCMD) {
		Echo "Don't know how to make symbolic link!" ;
		return ;
	}

	Depends $(<) : $(>) ;

	if $(3) {
		SYMLINKSRCPATH on $(<) = $(3) ;
	} else {
		# Can't be empty or SymLink1 will ignore source; also
		# it is set on $(<) jam only via this way see it as valid variable
		SYMLINKSRCPATH on $(<) = "" ;
	}

	SymLink1 $(<) : $(>) ;
	Clean clean : $(<) ;
}

actions SymLink1
{
	$(RM) "$(<)" && $(LINKCMD) "$(>:D=$(SYMLINKSRCPATH))" "$(<)"
}

rule SharedLibraryFromObjects
{
	if ! $(UNIX) {
		Echo "Dynamic libraries can't be built on this OS for now" ;
		return ;
	}

	local s t t_only tmp ;

	t = $(1) ;
	s = [ FGristFiles $(2) ] ;

	# figure out correct library name for -soname flag; it should
	# accept libname.so.X when given libname.so.X.X.X so ldconfig
	# can generate correct symling (reading soname section from library)
	if $(t:S) {
		# remove .so.X.X.X
		t_only = [ MATCH "(.*)\.so\.[0-9]\.[0-9]\.[0-9]$" : $(t) ] ;
		# directory and grist too
		t_only = $(t_only:D=:G=) ;
		# pick X.X.X from .so.X.X.X
		tmp = [ MATCH "\.([0-9])\.([0-9])\.([0-9])$" : $(t) ] ;

		if $(tmp[0]) {
			t_only = $(t_only:S="$(SOEXT).$(tmp[0])") ;
		} else {
			Exit "Bad shared library name: $(t). Must be in form: 'libname.so.X.X.X'" ;
		}

	} else {
		# no suffix, add SOEXT
		t = $(t:S=$(SOEXT)) ;
	}

	Depends lib : $(t) ;

	# This is used if library already does not have a path
	if ! $(t:D) {
		MakeLocate $(t) $(t)($(s:BS)) : $(LOCATE_TARGET) ;
	}

	if $(t_only) {
		LINKFLAGS on $(t) = -shared -Wl,-soname,\"$(t_only)\" [ on $(t) return $(LINKFLAGS) ] ;
	} else {
		# will this work ?
		LINKFLAGS on $(t) = -shared -Wl [ on $(t) return $(LINKFLAGS) ] ;
	}

	# Let target is dependant on source
	Depends $(t) : $(s) ;

	Link $(t) : $(s) ;
	Clean clean : $(t) ;
}

# MakeStaticLibrary <libname> : <sources> ;
# a rule using jam's default Library with meaningfull name
rule MakeStaticLibrary
{
	Library $(<) : $(>) ;
}

# MakeSharedLibrary <libname> : <sources> ;
# Create shared library (suffix will be appended), creating symlink to it.
#
# This is probably a good candidate for libtool backend, but
# later is story for it's own; for now we stick with direct compiler flags
# and if breaks something, addons will be done.
# It use SOEXTFULL as full shared library extension and SOEXT as symlink 
# extension to it.
rule MakeSharedLibrary
{
	local shlib = $(1) ;
	local src = $(2) ;
	local objects = [ FGristFiles $(src:S=$(SUFOBJ)) ] ;
	local symlink ;

	if ! $(SOFLAGS) {
		Echo "SOFLAGS not defined; will not touch a thing" ;
		return ;
	}

	CCFLAGS on $(objects) += $(SOFLAGS) ;
	C++FLAGS on $(objects) += $(SOFLAGS) ;

	# append suffixes
	shlib = $(1:S=$(SOEXTFULL)) ;
	symlink = $(1:S=$(SOEXT)) ;

	SharedLibraryFromObjects $(shlib) : $(objects) ;
	Objects $(src) ;

	# copy target directory or symlink will be created
	# in directory where jam was called
	LOCATE on $(symlink) = [ on $(1) return $(LOCATE) ] ;

	Depends lib : $(symlink) ;

	SymLink $(symlink) : $(shlib) ;
	Clean clean : $(symlink) ;
}

# MakeTest <target> : <sources> : <optional-libraries> ;
# Rule used to correctly compule library path, do linking and stuff
# for edelib specific tests
rule MakeTest
{
	local addon_flags ldir ;

	addon_flags = "-rdynamic" ;
	#addon_flags = "-pg" ;

	# construct path so compiler knows where is library
	ldir = [ FDirName $(TOP) $(EDELIB_LIBDIR) ] ;

	Depends $(<) : lib ;
	Depends tests : $(<) ;

	LINKFLAGS on $(<) = $(addon_flags) [ on $(<) return $(LINKFLAGS) ] ;
	Main $(<) : $(>) ;
	LinkAgainst $(<) : -L$(ldir) -l$(EDELIB) $(3) -l$(STDLIB) ;
}

# MakeApiDocumentation <full-path-to-directory> : <full-path-to-doxyfile> ;
# Create api documentation via doxygen; not full paths are required
# since doxygen don't have any external option to specify path for Doxyfile
# or path for output directory
rule MakeApiDocumentation 
{
	if $(DOXYGEN) 
	{
		Depends doc : $(<) ;
		Depends $(<) : $(>) ;
		Depends all : doc ;

		MakeApiDocumentation1 $(<) : $(>) ;
		Cleandir clean : $(<) ;
	}

	# just return if doxygen is not found
	# so we can build the rest
	if ! $(DOXYGEN)
	{
		Echo "doxygen is missing; skiping..." ;
		return ;
	}
}

# Strip directory path from (example: 'doc/Doxyfile') and
# go into it so DOXYGEN command can work
actions piecemeal MakeApiDocumentation1
{
	cd $(>:D)
	$(DOXYGEN) $(>:B) ;
}

# GenDocumentation <path-to-target> : <path-to-command> <path-to-source> ;
# Aimed for generating text files from doxygen source;
# probably this should be called GenerateFile or something.
rule GenDocumentation
{
	local target = $(<) ;
	local cmd = $(>[1]) ;
	local src = $(>[2]) ;

	Depends $(target) : $(src) ;
	Depends $(src) : $(cmd) ;
	Depends doc : $(target) ;
	Clean clean : $(target) ;
}

actions GenDocumentation
{
	./$(>[1]) $(>[2]) > $(<) ;
}

# InstallStaticLibrary <destination> : <lib-file> ;
# Installs static library to destination
rule InstallStaticLibrary
{
	local t dir lfix ;
	dir = $(<) ;

	# construct valid installed library name with end path with it's grist
	t = $(>:BSR=$(dir)) ;
	t = $(t:G=installstaticlibrary) ;
	t = $(t:S=$(SUFLIB)) ;

	lfix = $(>:S=$(SUFLIB)) ;

	Depends install : lib $(dir) $(t) ;
	
	MkDir $(dir) ;
	INSTALL on $(t) = $(CP) ;
	Install1 $(t) : $(lfix) ;

	Clean uninstall : $(t) ;
}

# InstallSharedLibrary <destination> : <lib-file> ;
# Installs shared library to destination, installing
# symbolic link too
rule InstallSharedLibrary
{
	local t sl dir lfix slfix ;
	dir = $(<) ;

	# construct valid installed library name with end path with it's grist
	t = $(>:BSR=$(dir)) ;
	t = $(t:G=installsharedlibrary) ;
	t = $(t:S=$(SOEXTFULL)) ;

	# now the same for symlink
	sl = $(>:BSR=$(dir)) ;
	sl = $(sl:G=installsymlink) ;
	sl = $(sl:S=$(SOEXT)) ;

	# full local library names
	lfix = $(>:S=$(SOEXTFULL)) ;
	slfix = $(>:S=$(SOEXT)) ;

	Depends install : lib $(dir) $(t) $(sl) ;
	
	MkDir $(dir) ;
	INSTALL on $(t) = $(CP) ;
	Install1 $(t) : $(lfix) ;

	# make system wide symlink, since CP mess things up
	SymLink $(sl) : $(t) : "" ;

	Clean uninstall : $(t) ;
	Clean uninstall : $(sl) ;
}

# InstallDocumentation <directory> : <source> ;
# Copy source file to target directory
rule InstallDocumentation
{
	local t ;
	t = [ FFileName $(<) $(>:D=) ] ;
	t = $(t:G=installdoc) ;

	MkDir $(<) ;

	Depends $(<) : $(>) ;
	Depends $(t) : $(<) ;
	Depends install : $(t) ;
	INSTALL on $(t) = $(CP) ;
	Install1 $(t) : $(>) ;

	Clean uninstall : $(t) ;
}

# InstallProgram <directory> : <source> ;
# Copy program to target directory
rule InstallProgram
{
	local t ;
	t = [ FFileName $(<) $(>:D=) ] ;
	t = $(t:G=installprogram) ;

	MkDir $(<) ;

	Depends $(<) : $(>) ;
	Depends $(t) : $(<) ;
	Depends install : $(t) ;
	INSTALL on $(t) = $(CP) ;
	Install1 $(t) : $(>) ;

	Clean uninstall : $(t) ;
}

# InstallDirectory <where> : <source-directory> ;
# Copy directory to given path
rule InstallDirectory
{
	local t;

	t = [ FDirName $(<) $(>) ] ;

	SEARCH on $(>) = $(SUBDIR) ;

	MkDir $(<) ;
	Depends $(<) : $(>) ;
	Depends $(t) : $(<) ;
	Depends install : $(t) ;
	INSTALL on $(t) = $(COPYDIR) ;
	Install1 $(t) : $(>) ;

	Cleandir uninstall : $(t) ;
}

actions Install1
{
	$(INSTALL) "$(>)" "$(<:D)"
}

rule Help
{
	Always $(<) ;
	OSNAME on help = [ GetOS ] ;
	Help1 help ;
}

actions quietly Help1
{
	echo "Detected OS: $(OSNAME)"
	echo ""
	echo "Build options:"
	echo "   jam          build all"
	echo "   jam lib      make library only"
	echo "   jam doc      create documentation"
	echo "   jam tests    make tests"
	echo "   jam clean    clean compiled data"
	echo "   jam help     you already see it"
	echo ""
	echo "Options can be grouped too so to make library"
	echo "and tests, command is: 'jam lib tests'"
}

Help help ;

NotFile help install ;
Always help ;

# a generated junk
Clean distclean : configure 
				  aclocal.m4 
				  Jamconfig 
				  edelib-config
				  config.log 
				  config.status 
				  edelib/_conf.h.in 
				  edelib/_conf.h 
				  doc/Doxyfile 
				  edelib/Version.h ;

Cleandir distclean : autom4te.cache ;

#
# $Id$
#
# Part of edelib.
# Copyright (c) 2005-2007 EDE Authors.
#
# This program is licenced under terms of the 
# GNU General Public Licence version 2 or newer.
# See COPYING for details.

# only for haiku jam
JCACHEFILE = $(TOP)/.jamcache ;
HCACHEFILE = $(TOP)/.jamhcache ;

if $(NOJAMCFG) {
	# for testing purposes
	LINKCMD = "ln -s" ;
	SHARED = "" ;
	SOEXTFULL = ".so.2.0.0" ;
	SOEXT = ".so" ;
	ALLFLAGS = "-Wall -shared" ;
	DOXYGEN = "doxygen" ;
	libdir = "/opt/ede/lib" ;
	docdir = "/opt/ede/doc" ;
	includedir  = "/opt/ede/include" ;
	INSTALL         ?= "ginstall -c" ;
	INSTALL_DATA    ?= "$(INSTALL) -m 644" ;
	INSTALL_PROGRAM ?= "$(INSTALL)" ;
	INSTALL_SCRIPT  ?= "$(INSTALL)" ;
	EDELIB_VERSION  ?= "2.0.0a" ;
} else {
	JAMCONFIG ?= $(TOP)/Jamconfig ;
	include $(JAMCONFIG) ;

	if ! $(JAMCONFIG_READ) {
		Exit "Can't find Jamconfig. Did you run 'configure' first ?" ;
	}

	# variables used by MakeSharedLibrary
	SOEXT     = $(DSOSYMLINK) ;
	SOEXTFULL = $(DSOSUFFIX) ;
	SOLDFLAGS = $(DSOLDFLAGS) ;
	SOFLAGS   = $(DSOFLAGS) ;

	LINKCMD = $(SYMLINKCMD) ;
}

# these variables should be here (not in Jamconfig) since RMDIR
# is already defined as 'rm -f' in Jambase, and calling 'jam distclean'
# will revert it's value when we remove Jamconfig
RMDIR   = "rm -R" ;
COPYDIR = "cp -R" ;

# general flags we pull from Jamconfig, with addition of include
# directory search, so compiler can find edelib include directory
FLAGS  = $(ALLFLAGS) -I$(TOP) ;

# standard C++ library we link with; for now is gcc's default
STDLIB ?= stdc++ ;

# variables used by jam directly
# OPTIM is cleared so it don't collide with FLAGS
OPTIM    = ;
CCFLAGS  = $(FLAGS) ;
C++FLAGS = $(FLAGS) ;

# directories used to place final library and 
# by tests to construct correct paths
EDELIB_INCLUDEDIR = edelib ;
EDELIB_LIBDIR     = lib ;

# library names
EDELIB      = edelib ;
EDELIB_NAME = libedelib ;

# directory name for installed documentation
EDELIB_DOCDIR      = "$(EDELIB)-$(EDELIB_VERSION)" ;

# used by SymLink
SYMLINKSRCPATH = ;

# Haiku jam have builtin LocalClean and LocalDepends
if ! $(INVOCATION_SUBDIR_SET) {
	rule LocalClean { Clean $(1) : $(2) ; }
	rule LocalDepends { Depends $(1) : $(2) ; }
}

rule GetOS
{
	local var ;
	var = [ MATCH "(.*[^ \t])" : $(JAMUNAME) ] ;
	return "$(var[5]) $(var[0])" ;
}

# construct path from list members
# same as FDirName, but targeted to files
rule FFileName
{
	return [ FDirName $(<) ] ;
}

# Cleandir cleandir : <directory> ;
# Removes directory in 'Clean clean' fashion
actions piecemeal together existing Cleandir
{
	$(RMDIR) $(>)
}

# LinkAgainst <target> : <libraries> ;
# The sam as jam's LinkLibraries, but will not mark those libraries 
# for building. <libraries> should be in form '-lfoo'
rule LinkAgainst
{
	LINKLIBS on $(1) = [ on $(1) return $(LINKLIBS) ] $(2) ;
}

# SymLink <link> : <source> : <optional-path-to-source> ;
# create symbolic link from parameters, removing existing one
# it use LINKCMD variable and is expecting 'ln -s' style
rule SymLink
{
	if ! $(LINKCMD) {
		Echo "Don't know how to make symbolic link!" ;
		return ;
	}

	LocalDepends $(<) : $(>) ;

	if $(3) {
		SYMLINKSRCPATH on $(<) = $(3) ;
	} else {
		# Can't be empty or SymLink1 will ignore source; also
		# it is set on $(<) jam only via this way see it as valid variable
		SYMLINKSRCPATH on $(<) = "" ;
	}

	SymLink1 $(<) : $(>) ;
	LocalClean clean : $(<) ;
}

actions SymLink1
{
	$(RM) "$(<)" && $(LINKCMD) "$(>:D=$(SYMLINKSRCPATH))" "$(<)"
}

rule SharedLibraryFromObjects
{
	if ! $(UNIX) {
		Echo "Dynamic libraries can't be built on this OS for now" ;
		return ;
	}

	local s t t_only tmp ;

	t = $(1) ;
	s = [ FGristFiles $(2) ] ;

	# figure out correct library name for -soname flag; it should
	# accept libname.so.X when given libname.so.X.X.X so ldconfig
	# can generate correct symling (reading soname section from library)
	if $(t:S) {
		# remove .so.X.X.X
		t_only = [ MATCH "(.*)\.so\.[0-9]\.[0-9]\.[0-9]$" : $(t) ] ;
		# directory and grist too
		t_only = $(t_only:D=:G=) ;
		# pick X.X.X from .so.X.X.X
		tmp = [ MATCH "\.([0-9])\.([0-9])\.([0-9])$" : $(t) ] ;

		if $(tmp[0]) {
			t_only = $(t_only:S="$(SOEXT).$(tmp[0])") ;
		} else {
			Exit "Bad shared library name: $(t). Must be in form: 'libname.so.X.X.X'" ;
		}

	} else {
		# no suffix, add SOEXT
		t = $(t:S=$(SOEXT)) ;
	}

	LocalDepends lib : $(t) ;

	# This is used if library already does not have a path
	if ! $(t:D) {
		MakeLocate $(t) $(t)($(s:BS)) : $(LOCATE_TARGET) ;
	}

	if $(t_only) {
		LINKFLAGS on $(t) = -shared -Wl,-soname,\"$(t_only)\" [ on $(t) return $(LINKFLAGS) ] ;
	} else {
		# will this work ?
		LINKFLAGS on $(t) = -shared -Wl [ on $(t) return $(LINKFLAGS) ] ;
	}

	# Let target is dependant on source
	LocalDepends $(t) : $(s) ;

	Link $(t) : $(s) ;
	LocalClean clean : $(t) ;
}

# MakeStaticLibrary <libname> : <sources> ;
# a rule using jam's default Library with meaningfull name
rule MakeStaticLibrary
{
	Library $(<) : $(>) ;
}

# MakeSharedLibrary <libname> : <sources> ;
# Create shared library (suffix will be appended), creating symlink to it.
#
# This is probably a good candidate for libtool backend, but
# later is story for it's own; for now we stick with direct compiler flags
# and if breaks something, addons will be done.
# It use SOEXTFULL as full shared library extension and SOEXT as symlink 
# extension to it.
rule MakeSharedLibrary
{
	local shlib = $(1) ;
	local src = $(2) ;
	local objects = [ FGristFiles $(src:S=$(SUFOBJ)) ] ;
	local symlink ;

	if ! $(SOFLAGS) {
		Echo "SOFLAGS not defined; will not touch a thing" ;
		return ;
	}

	CCFLAGS on $(objects) += $(SOFLAGS) ;
	C++FLAGS on $(objects) += $(SOFLAGS) ;

	# append suffixes
	shlib = $(1:S=$(SOEXTFULL)) ;
	symlink = $(1:S=$(SOEXT)) ;

	SharedLibraryFromObjects $(shlib) : $(objects) ;
	Objects $(src) ;

	# copy target directory or symlink will be created
	# in directory where jam was called
	LOCATE on $(symlink) = [ on $(1) return $(LOCATE) ] ;

	LocalDepends lib : $(symlink) ;

	SymLink $(symlink) : $(shlib) ;
	LocalClean clean : $(symlink) ;
}

# MakeTest <target> : <sources> : <optional-libraries> ;
# Rule used to correctly compule library path, do linking and stuff
# for edelib specific tests
rule MakeTest
{
	local addon_flags ldir ;

	addon_flags = "-rdynamic" ;
	#addon_flags = "-pg" ;

	# construct path so compiler knows where is library
	ldir = [ FDirName $(TOP) $(EDELIB_LIBDIR) ] ;

	LocalDepends $(<) : lib ;
	LocalDepends tests : $(<) ;

	LINKFLAGS on $(<) = $(addon_flags) [ on $(<) return $(LINKFLAGS) ] ;
	Main $(<) : $(>) ;
	LinkAgainst $(<) : -L$(ldir) -l$(EDELIB) $(3) -l$(STDLIB) ;
}

# MakeApiDocumentation <full-path-to-directory> : <full-path-to-doxyfile> ;
# Create api documentation via doxygen; not full paths are required
# since doxygen don't have any external option to specify path for Doxyfile
# or path for output directory
rule MakeApiDocumentation 
{
	if $(DOXYGEN) 
	{
		LocalDepends doc : $(<) ;
		LocalDepends $(<) : $(>) ;
		LocalDepends all : doc ;

		MakeApiDocumentation1 $(<) : $(>) ;
		Cleandir clean : $(<) ;
	}

	# just return if doxygen is not found
	# so we can build the rest
	if ! $(DOXYGEN)
	{
		Echo "doxygen is missing; skiping..." ;
		return ;
	}
}

# Strip directory path from (example: 'doc/Doxyfile') and
# go into it so DOXYGEN command can work
actions piecemeal MakeApiDocumentation1
{
	cd $(>:D)
	$(DOXYGEN) $(>:B) ;
}

# MakeInstallPrivate <location-dir> : <targets> : <opt-file-mode> : <opt-chown> : <opt-chgrp> ;
rule MakeInstallPrivate
{
	local i t s ;
	local dir = $(1) ;

	MkDir $(dir) ;

	# This was pain-in-the-ass to set up (bad docs)
	# but this is the shortest possible explaination of it:
	# files must be gristed (or foo/foo will not be build) and _after_
	# that apply SEARCH on it, consulting SUBDIR. Otherwise
	# known targets will be compiled, but unknown (icons etc.) will not
	# be recognized as installable entity.
	s = [ FGristFiles $(2) ] ;
	SEARCH on $(s) = $(SUBDIR) ;

	for i in $(s) {
		t = $(i:BSR=$(dir):G=installed) ;
		LocalDepends $(t) : $(i) ;
		LocalDepends $(t) : $(dir) ;

		LocalDepends install : $(t) ;
		LocalClean uninstall : $(t) ;

		Install1 $(t) : $(i) ;

		if $(3) {
			MODE on $(t) = $(3) ;
			Chmod $(t) ;
		}

		if $(4) {
			OWNER on $(t) = $(4) ;
			Chown $(t) ;
		}

		if $(5) {
			GROUP on $(t) = $(5) ;
			Chgrp $(t) ;
		}
	}
}

# InstallStaticLibrary <location-dir> : <library> ;
rule InstallStaticLibrary
{
	MakeInstallPrivate $(<) : $(>:S=$(SUFLIB)) : $(FILEMODE) ;
}

# InstallSharedLibrary <location-dir> : <library> ;
rule InstallSharedLibrary
{
	local symlink = $(>:S=$(SOEXT)) ;
	MakeInstallPrivate $(<) : $(>:S=$(SOEXTFULL)) : $(EXEMODE) ;

	# create symbolic link
	# full path for source (to what will point to) is not needed
	# since symlink is placed in the same directory (e.g. will be libedelib.so -> libedelib.so.version)
	SymLink $(symlink:D=$(<)) : $(>:S=$(SOEXTFULL)) ;

	LocalDepends install : $(symlink:D=$(<)) ;
	LocalClean uninstall : $(symlink:D=$(<)) ;
}

# InstallProgram <location-dir> : <program> ;
# EXEMODE is not used (jam set it to 711)
rule InstallProgram
{
	MakeInstallPrivate $(<) : $(>) ;
}

# InstallDocumentation <location-dir> : <file> ;
rule InstallDocumentation
{
	MakeInstallPrivate $(<) : $(>) : $(FILEMODE) ;
}

# InstallDirectory <location-dir> : <directory> ;
rule InstallDirectory
{
	local dir = $(1) ;

	MkDir $(dir) ;

	s = [ FGristFiles $(2) ] ;
	SEARCH on $(s) = $(SUBDIR) ;

	for i in $(s) {
		t = $(i:BSR=$(dir):G=installed) ;
		LocalDepends $(t) : $(i) ;
		LocalDepends $(t) : $(dir) ;

		LocalDepends install : $(t) ;
		Cleandir uninstall : $(t) ;

		CP on $(t) = $(COPYDIR) ;
		Install1 $(t) : $(i) ;
	}
}

actions Install1
{
	$(CP) "$(>)" "$(<)"
}

rule Help
{
	Always $(<) ;
	OSNAME on help = [ GetOS ] ;
	Help1 help ;
}

actions quietly Help1
{
	echo ""
	echo "Build options:"
	echo "   jam          build all"
	echo "   jam lib      make library only"
	echo "   jam doc      create documentation"
	echo "   jam tests    make tests"
	echo "   jam clean    clean compiled data"
	echo "   jam help     you already see it"
	echo ""
	echo "Options can be grouped too so to make library"
	echo "and tests, command is: 'jam lib tests'"
}

Help help ;

NotFile help install ;
Always help ;

# a generated junk
LocalClean distclean : configure 
				  aclocal.m4 
				  Jamconfig 
				  edelib-config
				  config.log 
				  config.status 
				  edelib/_conf.h.in 
				  edelib/_conf.h 
				  doc/Doxyfile 
				  edelib/Version.h 
				  $(JCACHEFILE)
				  $(HCACHEFILE) ;

Cleandir distclean : autom4te.cache ;
